import struct


def decode_bmp(maze_bmp_data: bytes):
    # Currently only support cell_size = 1
    # only support maze generated by maze.bmp function

    BMP_HEADER_SIZE = 14

    cell_size = 1

    data_offset = struct.unpack_from('<I', maze_bmp_data, 10)[0]

    img_width = struct.unpack_from('<I', maze_bmp_data, BMP_HEADER_SIZE + 4)[0]
    img_height = struct.unpack_from('<I', maze_bmp_data, BMP_HEADER_SIZE + 8)[0]

    row_size = 4 * (((img_width + 7) // 8 + 3) // 4)

    maze = []

    for y in range(img_height):
        offset = data_offset + y * row_size
        row = int.from_bytes(maze_bmp_data[offset : offset + row_size])
        row >>= row_size * 8 - img_width
        maze.append(row)

    return maze[::-1]


def bmp_with_sol(maze, sol):
    maze_width = maze[0].bit_length()
    maze_height = len(maze)

    cell_size = 1

    # 2bpp is enough to draw maze and solution,
    # but most systems does not support 2bpp
    bpp = 4
    ncolors = 3

    # maze_width * cell_size pixel per row
    # 2 * maze_width * cell_size bits per row
    # 2 * maze_width * cell_size + 7 // 8 bytes per row
    # ((2 * maze_width * cell_size + 7 // 8) + 3) // 4
    row_size = 4 * (((bpp * maze_width * cell_size + 7) // 8 + 3) // 4)

    BMP_HEADER_SIZE = 14
    DIB_HEADER_SIZE = 40
    PALLETE_SIZE = 4 * ncolors
    BMP_DATA_SIZE = row_size * maze_height * cell_size
    FILE_SIZE = BMP_HEADER_SIZE + DIB_HEADER_SIZE + PALLETE_SIZE + BMP_DATA_SIZE
    BITMAP_OFFSET = FILE_SIZE - BMP_DATA_SIZE

    # Bitmap file header
    data = bytearray()
    data += b'BM'  # ID
    data += struct.pack('<I', FILE_SIZE)  # File size
    data += struct.pack('<h', 0)  # Unused
    data += struct.pack('<h', 0)  # Unused
    data += struct.pack('<I', BITMAP_OFFSET)  # Start of bitmap data

    # DIB header (BITMAPINFOHEADER)
    data += struct.pack('<I', 40)  # DIB header size
    data += struct.pack('<I', maze_width * cell_size)  # Image width
    data += struct.pack('<I', maze_height * cell_size)  # Image height
    data += struct.pack('<h', 1)  # Number of color planes
    data += struct.pack('<h', bpp)  # Bits per pixel
    data += struct.pack('<I', 0)  # Compression method
    data += struct.pack('<I', BMP_DATA_SIZE)  # Size of bitmap data
    data += struct.pack('<I', 3780)  # Horizontal resolution, pixel per meter
    data += struct.pack('<I', 3780)  # Vertical resolution, pixel per meter
    data += struct.pack('<I', ncolors)  # Number of colors in the color pallete
    data += struct.pack('<I', 0)  # Number of important colors

    # Color pallete
    data += bytearray.fromhex('FFFFFF00')  # White
    data += bytearray.fromhex('00000000')  # Black
    data += bytearray.fromhex('0000FF00')  # Red

    # Bitmap data
    _walls = 0
    for _ in range(cell_size):
        _walls <<= bpp
        _walls += 1
    for row in maze[::-1]:
        maze_data = 0
        walls = _walls
        for _ in range(maze_width):
            if row & 1:
                maze_data += walls
            walls <<= cell_size * bpp
            row >>= 1
        maze_data <<= row_size * 8 - cell_size * maze_width * bpp
        data += maze_data.to_bytes(row_size) * cell_size

    # Modify data to mark solution
    prev_x, prev_y = 1, -1

    _walls <<= 1  # change color

    def mark_path(x, y):
        offset = BITMAP_OFFSET + (maze_width - 1 - y) * cell_size * row_size
        row_data = data[offset : offset + row_size]
        row = int.from_bytes(row_data) >> row_size * 8 - cell_size * maze_width * bpp
        row += _walls << (maze_width - x - 1) * cell_size * bpp
        row <<= row_size * 8 - cell_size * maze_width * bpp
        row_data = row.to_bytes(row_size)
        data[offset : offset + cell_size * row_size] = row_data * cell_size

    for x, y in sol:
        _x, _y = x, y
        for _ in range(2):
            mark_path(_x, _y)
            _x = (prev_x + x) // 2
            _y = (prev_y + y) // 2
        prev_x, prev_y = x, y
    mark_path(maze_width - 2, maze_height - 1)

    return data


def decode_maze_str(maze_str, shaft='  ', wall='██'):
    maze = maze_str.split('\n')
    for i, row in enumerate(maze):
        row = row.replace(shaft, '0')
        row = row.replace(wall, '1')
        maze[i] = int(row, 2)
    return maze


def replace_char(str, i, char):
    return str[:i] + char + str[i + 1 :]


def maze_str_with_sol(maze, sol):
    w = maze[0].bit_length()
    h = len(maze)
    maze_str = '\n'.join(f'{row:b}' for row in maze)
    prev_x, prev_y = 1, -1
    for x, y in sol:
        maze_str = replace_char(
            maze_str, (prev_y + y) // 2 * (w + 1) + (prev_x + x) // 2, '2'
        )
        maze_str = replace_char(maze_str, y * (w + 1) + x, '2')
        prev_x, prev_y = x, y
    maze_str = replace_char(maze_str, h * (w + 1) - 3, '2')
    maze_str = maze_str.replace('0', '  ')
    maze_str = maze_str.replace('1', '██')
    maze_str = maze_str.replace('2', '[]')
    return maze_str


def dfs(maze):

    w = maze[0].bit_length()
    h = len(maze)

    # block entrance
    maze[0] += 1 << w - 2

    # x, y interval is one cell (as is)
    cur = (1, 1)
    path = [cur]
    stack = []

    def step():
        cur, prev_move_inverse, neighbors = stack[-1]
        x, y = cur

        if x == w - 2 and y == h - 2:
            # Maze solved
            return True

        if neighbors is None:
            neighbors = [(0, 1), (0, -1), (-1, 0), (1, 0)]
            for j in (3, 2, 1, 0):
                if neighbors[j] == prev_move_inverse:
                    # Visited
                    neighbors.pop(j)
                    continue
                dx, dy = neighbors[j]
                if (maze[y + dy] >> w - (x + dx) - 1) & 1:
                    neighbors.pop(j)
            stack[-1] = (cur, prev_move_inverse, neighbors)

        if len(neighbors) == 0:
            stack.pop()
            path.pop()
            return False

        dx, dy = neighbors.pop()
        prev_move_inverse = (-dx, -dy)
        cur = (x + 2 * dx, y + 2 * dy)
        stack.append((cur, prev_move_inverse, None))
        path.append(cur)

        return False

    stack.append((cur, None, None))
    while not step():
        pass

    # restore entrance
    maze[0] -= 1 << w - 2

    return path


def main():
    with open('maze.bmp', 'rb') as f:
        data = f.read()

    decoded = decode_bmp(data)
    solution = dfs(decoded)
    data = bmp_with_sol(decoded, solution)

    with open('maze_solved.bmp', 'wb') as f:
        f.write(data)


if __name__ == '__main__':
    main()
